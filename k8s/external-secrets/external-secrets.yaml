# ============================================
# External Secrets Configuration
# ============================================
# Purpose: Sync secrets from AWS Secrets Manager into Kubernetes Secrets
# Usage: kubectl apply -f k8s/external-secrets/external-secrets.yaml
#
# HOW IT WORKS:
# 1. SecretStore defines AWS Secrets Manager as source (uses IRSA)
# 2. ExternalSecret references SecretStore and maps AWS secret keys to K8s secret keys
# 3. ESO syncs automatically and keeps Kubernetes Secret updated
# 4. Pods use Kubernetes Secret normally via secretKeyRef
#
# NOTE: Replace secret ARNs with actual values from Terraform output:
#   terraform output secrets_manager_arns

# ============================================
# SecretStore: Defines AWS Secrets Manager as source
# ============================================
# SecretStore tells ESO where to fetch secrets from
# Uses IRSA: ESO service account needs IAM role annotation

apiVersion: external-secrets.io/v1beta1
kind: SecretStore
metadata:
  name: aws-secrets-manager
  namespace: payflow
spec:
  provider:
    aws:
      service: SecretsManager
      region: us-east-1  # Change to your AWS region
      # Uses IRSA: ESO service account must have IAM role annotation
      # No accessKeyId or secretAccessKey needed - IRSA handles authentication
---
# ============================================
# ExternalSecret: PostgreSQL Credentials
# ============================================
# Syncs PostgreSQL username and password from AWS Secrets Manager
# AWS secret format: {"username": "...", "password": "..."}

apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: postgres-credentials
  namespace: payflow
spec:
  refreshInterval: 1h  # Sync every hour
  secretStoreRef:
    name: aws-secrets-manager
    kind: SecretStore
  target:
    name: db-secrets  # Kubernetes Secret name (same as existing)
    creationPolicy: Merge  # Merge with existing secret (keeps RabbitMQ credentials)
  data:
    # Extract username from AWS Secrets Manager JSON and map to DB_USER key
    - secretKey: DB_USER
      remoteRef:
        key: REPLACE_WITH_POSTGRES_SECRET_ARN  # e.g., payflow-production-postgres-xxxxx
        property: username  # Extract username from JSON: {"username": "...", "password": "..."}
    # Extract password from AWS Secrets Manager JSON and map to DB_PASSWORD key
    - secretKey: DB_PASSWORD
      remoteRef:
        key: REPLACE_WITH_POSTGRES_SECRET_ARN  # Same secret ARN
        property: password  # Extract password from JSON
---
# ============================================
# ExternalSecret: JWT Secret
# ============================================
# Syncs JWT signing key from AWS Secrets Manager
# AWS secret format: {"jwt_secret": "..."}

apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: jwt-secret
  namespace: payflow
spec:
  refreshInterval: 1h
  secretStoreRef:
    name: aws-secrets-manager
    kind: SecretStore
  target:
    name: db-secrets  # Merge into same secret
    creationPolicy: Merge
  data:
    # Extract jwt_secret from AWS Secrets Manager JSON and map to JWT_SECRET key
    - secretKey: JWT_SECRET
      remoteRef:
        key: REPLACE_WITH_JWT_SECRET_ARN  # e.g., payflow-production-jwt-xxxxx
        property: jwt_secret  # Extract jwt_secret from JSON: {"jwt_secret": "..."}
---
# ============================================
# ExternalSecret: Redis Auth Token
# ============================================
# Syncs Redis authentication token from AWS Secrets Manager
# AWS secret format: {"auth_token": "...", "host": "...", "port": "..."}

apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: redis-auth-token
  namespace: payflow
spec:
  refreshInterval: 1h
  secretStoreRef:
    name: aws-secrets-manager
    kind: SecretStore
  target:
    name: db-secrets  # Merge into same secret
    creationPolicy: Merge
  data:
    # Extract auth_token from AWS Secrets Manager JSON and map to REDIS_AUTH_TOKEN key
    - secretKey: REDIS_AUTH_TOKEN
      remoteRef:
        key: REPLACE_WITH_REDIS_SECRET_ARN  # e.g., payflow-production-redis-xxxxx
        property: auth_token  # Extract auth_token from JSON: {"auth_token": "..."}
---
# ============================================
# ExternalSecret: RabbitMQ Credentials
# ============================================
# Syncs RabbitMQ username and password from AWS Secrets Manager
# AWS secret format: {"username": "...", "password": "..."}

apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: rabbitmq-credentials
  namespace: payflow
spec:
  refreshInterval: 1h
  secretStoreRef:
    name: aws-secrets-manager
    kind: SecretStore
  target:
    name: db-secrets  # Merge into same secret
    creationPolicy: Merge
  data:
    # Extract username from AWS Secrets Manager JSON and map to RABBITMQ_USER key
    - secretKey: RABBITMQ_USER
      remoteRef:
        key: REPLACE_WITH_RABBITMQ_SECRET_ARN  # e.g., payflow-production-rabbitmq-xxxxx
        property: username  # Extract username from JSON: {"username": "...", "password": "..."}
    # Extract password from AWS Secrets Manager JSON and map to RABBITMQ_PASSWORD key
    - secretKey: RABBITMQ_PASSWORD
      remoteRef:
        key: REPLACE_WITH_RABBITMQ_SECRET_ARN  # Same secret ARN
        property: password  # Extract password from JSON
---
# ============================================
# HYBRID CLOUD SUPPORT: Azure Key Vault SecretStore
# ============================================
# Purpose: Use Azure Key Vault alongside AWS Secrets Manager
# Why Hybrid: Different secrets in different clouds, gradual migration, compliance
#
# HOW IT WORKS:
# - You can have multiple SecretStores (AWS + Azure)
# - ExternalSecrets can reference different SecretStores
# - Same Kubernetes Secret can be populated from multiple sources using Merge policy
#
# Example: PostgreSQL secrets from AWS, API keys from Azure Key Vault
#
# To use Azure Key Vault:
# 1. Create Azure Key Vault and service principal
# 2. Deploy Azure Key Vault CSI Driver or use External Secrets Operator
# 3. Create SecretStore for Azure Key Vault (see below)
# 4. Create ExternalSecret referencing azure-key-vault SecretStore

apiVersion: external-secrets.io/v1beta1
kind: SecretStore
metadata:
  name: azure-key-vault
  namespace: payflow
spec:
  provider:
    azurekv:
      # Azure Key Vault configuration
      vaultUrl: "https://REPLACE_WITH_KEY_VAULT_NAME.vault.azure.net"
      # Authentication options:
      # Option 1: Service Principal (using Kubernetes Secret)
      authType: ServicePrincipal
      tenantId: "REPLACE_WITH_AZURE_TENANT_ID"
      # Reference to Kubernetes Secret containing Azure credentials
      # Secret should have: clientId, clientSecret
      authSecretRef:
        clientId:
          name: azure-credentials
          key: clientId
        clientSecret:
          name: azure-credentials
          key: clientSecret
      # Option 2: Managed Identity (if using Azure AKS)
      # authType: ManagedIdentity
      # clientId: "REPLACE_WITH_MANAGED_IDENTITY_CLIENT_ID"
      # Option 3: Workload Identity (Azure Workload Identity)
      # authType: WorkloadIdentity
      # serviceAccountRef:
      #   name: azure-workload-identity-sa
      #   namespace: payflow
---
# ============================================
# Example ExternalSecret: Azure Key Vault
# ============================================
# Purpose: Sync secrets from Azure Key Vault
# Example: API keys stored in Azure Key Vault

# apiVersion: external-secrets.io/v1beta1
# kind: ExternalSecret
# metadata:
#   name: azure-api-keys
#   namespace: payflow
# spec:
#   refreshInterval: 1h
#   secretStoreRef:
#     name: azure-key-vault
#     kind: SecretStore
#   target:
#     name: db-secrets  # Merge into same secret
#     creationPolicy: Merge
#   data:
#     # Sync API key from Azure Key Vault
#     - secretKey: AZURE_API_KEY
#       remoteRef:
#         key: payflow-api-key  # Secret name in Azure Key Vault
#         # Azure Key Vault stores secrets as strings, not JSON
#         # So we don't need property extraction
# ---
# ============================================
# Kubernetes Secret: Azure Credentials (for Service Principal auth)
# ============================================
# Purpose: Store Azure Service Principal credentials for Key Vault access
# NOTE: This is only needed if using Service Principal authentication
# For Managed Identity or Workload Identity, skip this secret

# apiVersion: v1
# kind: Secret
# metadata:
#   name: azure-credentials
#   namespace: payflow
# type: Opaque
# stringData:
#   clientId: "REPLACE_WITH_AZURE_CLIENT_ID"
#   clientSecret: "REPLACE_WITH_AZURE_CLIENT_SECRET"
# ---
# ============================================
# HYBRID EXAMPLE: Same Secret from Multiple Sources
# ============================================
# You can populate the same Kubernetes Secret from multiple providers:
#
# 1. PostgreSQL secrets from AWS Secrets Manager (already configured above)
# 2. Redis secrets from AWS Secrets Manager (already configured above)
# 3. API keys from Azure Key Vault (example above)
#
# All will merge into the same 'db-secrets' Kubernetes Secret using Merge policy
#
# This allows:
# - Gradual migration from one cloud to another
# - Different secrets in different clouds (compliance, cost optimization)
# - Disaster recovery scenarios

